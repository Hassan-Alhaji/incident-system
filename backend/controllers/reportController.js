const prisma = require('../prismaClient');

// @desc    Export ticket report to PDF (Basic implementation / Placeholder)
// @route   POST /api/tickets/:id/export-pdf
// @access  Private
const fs = require('fs');
const path = require('path');
const PDFDocument = require('pdfkit');
const QRCode = require('qrcode');

// @desc    Export ticket report to PDF
// @route   POST /api/tickets/:id/export-pdf
// @access  Private
const exportPdf = async (req, res) => {
    const ticketId = req.params.id;

    try {
        // 1. Fetch Comprehensive Data
        const ticket = await prisma.ticket.findUnique({
            where: { id: ticketId },
            include: {
                createdBy: true,
                medicalReport: { include: { author: true } },
                controlReport: true,
                safetyReport: true,
                pitGridReport: true,
                attachments: true,
                activityLogs: {
                    include: { actor: true },
                    orderBy: { createdAt: 'asc' } // Chronological order
                }
            }
        });

        if (!ticket) {
            return res.status(404).json({ message: 'Ticket not found' });
        }

        // 2. Setup Document & Stream
        const verifyToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        const fileName = `report-${ticket.ticketNo}.pdf`;

        // Set Headers for Download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);

        const doc = new PDFDocument({ margin: 40, size: 'A4' });
        doc.pipe(res); // Stream directly to client

        // --- Helper Functions ---
        const colors = {
            primary: '#15803d', // SAMF Green (700)
            secondary: '#16a34a', // Green (600)
            accent: '#e53e3e', // Red
            text: '#2d3748',
            gray: '#718096',
            lightGray: '#f0fdf4', // Green-50
            border: '#e2e8f0'
        };

        const drawSection = (title, y) => {
            doc.rect(40, y, 515, 25).fill(colors.primary);
            doc.fillColor('white').fontSize(12).font('Helvetica-Bold').text(title, 50, y + 7);
            doc.fillColor(colors.text); // Reset
            return y + 35;
        };

        const drawField = (label, value, x, y, width = 250) => {
            doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), x, y);
            doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(value || '-', x, y + 12, { width: width - 10 });
        };

        const checkPageBreak = (neededSpace) => {
            if (doc.y + neededSpace > 700) { // Reduced threshold to make room for footer
                doc.addPage();
                return true;
            }
            return false;
        };

        // Footer Logic
        const addFooter = () => {
            const bottom = doc.page.height - 50;
            doc.save();
            doc.fontSize(8).font('Helvetica-Bold').fillColor(colors.primary)
                .text('All Rights Reserved to Saudi Automobile & Motorcycle Federation (SAMF)', 50, bottom, { align: 'center', width: 500 });
            doc.fontSize(8).font('Helvetica').fillColor(colors.gray)
                .text('Generated by Incident Management System', 50, bottom + 12, { align: 'center', width: 500 });
            doc.restore();
        };

        doc.on('pageAdded', addFooter);

        // ================= HEADER =================
        addFooter(); // Add footer to first page manually
        const logoPath = path.join(__dirname, '..', 'assets', 'logo_placeholder.png');
        if (fs.existsSync(logoPath)) {
            doc.image(logoPath, 40, 40, { height: 40 });
        }

        doc.fontSize(24).font('Helvetica-Bold').fillColor(colors.primary).text('MEDICAL & INCIDENT REPORT', { align: 'center' });
        doc.fontSize(10).font('Helvetica').fillColor(colors.gray).text('CONFIDENTIAL DOCUMENT', { align: 'center', characterSpacing: 2 });
        doc.moveDown();

        // Top Info Bar
        const topY = 100;
        doc.rect(40, topY, 515, 60).fillColor(colors.lightGray).fill();

        doc.fillColor(colors.text);
        drawField('Ticket Number', ticket.ticketNo, 50, topY + 10, 150);
        drawField('Status', ticket.status.replace(/_/g, ' '), 200, topY + 10, 150);
        drawField('Priority', ticket.priority, 350, topY + 10, 100);

        drawField('Date', new Date().toLocaleDateString(), 50, topY + 35, 150);
        drawField('Time', new Date().toLocaleTimeString(), 200, topY + 35, 150);
        drawField('Type', ticket.type, 350, topY + 35, 100);

        let currentY = topY + 70;

        // ================= SECTION 1: INCIDENT INFORMATION =================
        currentY = drawSection('1. INCIDENT DETAILS', currentY);

        drawField('Event Name', ticket.eventName, 50, currentY);
        drawField('Venue', ticket.venue, 300, currentY);

        drawField('Location', ticket.location, 50, currentY + 35);

        const reporterText = `${ticket.createdBy?.name}\nPh: ${ticket.createdBy?.mobile || '-'} | ${ticket.createdBy?.email || '-'}`;
        drawField('Reporter', reporterText, 300, currentY + 35);

        doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text('DESCRIPTION', 50, currentY + 95);
        doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(ticket.description, 50, currentY + 107, { width: 500 });

        currentY = doc.y + 20;

        // ================= SECTION 2: MEDICAL INFORMATION =================
        if (ticket.medicalReport) {
            const m = ticket.medicalReport;

            // Reduce threshold to Avoid premature breaks (Header + 1st row needs ~80pts)
            checkPageBreak(120);
            currentY = drawSection('2. PATIENT INFORMATION', currentY);

            drawField('Full Name', `${m.patientGivenName || ''} ${m.patientSurname || ''}`.trim() || m.patientName, 50, currentY);
            drawField('Date of Birth', m.patientDob ? new Date(m.patientDob).toLocaleDateString() : '-', 300, currentY);

            drawField('Gender', m.patientGender, 50, currentY + 35);
            drawField('Occupation', m.patientOccupation, 300, currentY + 35);

            drawField('Role at Event', m.patientRole?.replace(/_/g, ' '), 50, currentY + 70);
            drawField('Car / Comp No', m.carNumber || m.patientCarNo, 300, currentY + 70);

            // Dynamically update currentY based on content drawn
            currentY += 105; // 3 rows * 35

            // Clinical
            checkPageBreak(120);
            currentY = drawSection('3. CLINICAL DETAILS', currentY);

            drawField('Injury Type', m.injuryType?.replace(/_/g, ' '), 50, currentY);
            drawField('Arrival Method', m.arrivalMethod?.replace(/_/g, ' '), 300, currentY);

            drawField('Treatment Loc', m.treatmentLocation?.replace(/_/g, ' '), 50, currentY + 35);
            drawField('License Action', m.licenseAction?.replace(/_/g, ' '), 300, currentY + 35);

            currentY += 70; // 2 rows * 35

            // Text Areas - Use doc.y to track actual height used
            const drawTextArea = (label, text) => {
                // Ensure we have space for Label + at least one line of text (~30pts)
                if (checkPageBreak(50)) {
                    currentY = doc.y; // Update currentY if page broke
                }

                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), 50, currentY);
                currentY += 15;

                doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(text || 'N/A', 50, currentY, { width: 500 });
                currentY = doc.y + 20; // Add padding after text block
            };

            drawTextArea('Condition on Arrival', m.initialCondition);
            drawTextArea('Treatment Performed', m.treatmentGiven);
            drawTextArea('Clinical Summary', m.summary);
            drawTextArea('Recommendation', m.recommendation);
        }

        // ================= SECTION 3: CONTROL / SPORT INFORMATION =================
        if (ticket.controlReport) {
            const c = ticket.controlReport;
            checkPageBreak(120);
            currentY = drawSection('3. CONTROL / SPORT REPORT', currentY);

            drawField('Competitor No', c.competitorNumber, 50, currentY);
            drawField('Lap Number', c.lapNumber ? c.lapNumber.toString() : '-', 200, currentY);
            drawField('Sector', c.sector ? c.sector.toString() : '-', 350, currentY);

            drawField('Violation', c.violationType?.replace(/_/g, ' '), 50, currentY + 35);
            drawField('Action Taken', c.actionTaken, 300, currentY + 35);

            drawField('Penalty Value', c.penaltyValue, 50, currentY + 70);

            currentY += 105;

            // Text Areas
            const drawTextArea = (label, text) => {
                if (checkPageBreak(50)) currentY = doc.y;
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), 50, currentY);
                currentY += 15;
                doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(text || 'N/A', 50, currentY, { width: 500 });
                currentY = doc.y + 20;
            };

            drawTextArea('Reasoning / Details', c.reasoning);
        }

        // ================= SECTION 4: SAFETY INFORMATION =================
        if (ticket.safetyReport) {
            const s = ticket.safetyReport;
            checkPageBreak(120);
            currentY = drawSection('4. SAFETY REPORT', currentY);

            drawField('Hazard Type', s.hazardType?.replace(/_/g, ' '), 50, currentY);
            drawField('Track Status', s.trackStatus, 300, currentY);

            drawField('Intervention', s.interventionRequired ? 'REQUIRED' : 'NO', 50, currentY + 35);
            drawField('Resources', s.resourcesDeployed, 300, currentY + 35);

            currentY += 70;

            const drawTextArea = (label, text) => {
                if (checkPageBreak(50)) currentY = doc.y;
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), 50, currentY);
                currentY += 15;
                doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(text || 'N/A', 50, currentY, { width: 500 });
                currentY = doc.y + 20;
            };

            drawTextArea('Location Detail', s.locationDetail);
            drawTextArea('Damage Description', s.damageDescription);
        }

        // ================= SECTION 5: INVESTIGATION INFORMATION =================
        if (ticket.investigationReport) {
            const inv = ticket.investigationReport;
            checkPageBreak(120);
            currentY = drawSection('5. INVESTIGATION REPORT', currentY);

            drawField('Responsible Party', inv.responsibleParty, 50, currentY);
            drawField('Decision', inv.decision, 300, currentY);
            currentY += 35;

            const drawTextArea = (label, text) => {
                if (checkPageBreak(50)) currentY = doc.y;
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), 50, currentY);
                currentY += 15;
                doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(text || 'N/A', 50, currentY, { width: 500 });
                currentY = doc.y + 20;
            };

            drawTextArea('Summary', inv.summary);
        }

        // ================= SECTION 6: PIT & GRID REPORT =================
        if (ticket.pitGridReport) {
            const p = ticket.pitGridReport;
            checkPageBreak(120);
            currentY = drawSection('6. PIT & GRID REPORT', currentY);

            drawField('Pit Number', p.pitNumber, 50, currentY);
            drawField('Session', p.sessionCategory, 200, currentY);
            drawField('Car No', p.carNumber, 350, currentY);

            drawField('Lap No', p.lapNumber ? p.lapNumber.toString() : '-', 50, currentY + 35);
            drawField('Team', p.teamName, 200, currentY + 35);
            drawField('Operator', p.radarOperatorName, 350, currentY + 35);

            currentY += 70;

            // Speed
            checkPageBreak(60);
            doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text('PIT SPEED', 50, currentY);
            currentY += 15;
            doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(`Limit: ${p.speedLimit || 'N/A'} | Recorded: ${p.speedRecorded || 'N/A'}`, 50, currentY);
            currentY += 25;

            // Violations
            const violations = [];
            if (p.drivingOnWhiteLine) violations.push('Driving on White Line');
            if (p.refueling) violations.push('Refueling Violation');
            if (p.driverChange) violations.push('Driver Change Violation');
            if (p.excessMechanics) violations.push('Excess Mechanics');

            if (violations.length > 0) {
                checkPageBreak(60);
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text('VIOLATIONS DETECTED', 50, currentY);
                currentY += 15;
                doc.fontSize(10).font('Helvetica').fillColor(colors.accent).text(violations.join(', '), 50, currentY);
                currentY += 25;
            }

            // Remarks
            const drawTextArea = (label, text) => {
                if (checkPageBreak(50)) currentY = doc.y;
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.gray).text(label.toUpperCase(), 50, currentY);
                currentY += 15;
                doc.fontSize(10).font('Helvetica').fillColor(colors.text).text(text || 'N/A', 50, currentY, { width: 500 });
                currentY = doc.y + 20;
            };

            drawTextArea('Remarks', p.remarks);
        }

        // ================= SECTION: ACTIVITY LOG & NOTES =================
        doc.addPage();
        currentY = 40;
        currentY = drawSection('ACTIVITY LOG & NOTES', currentY);

        if (ticket.activityLogs && ticket.activityLogs.length > 0) {
            ticket.activityLogs.forEach((log, index) => {
                checkPageBreak(60);

                // Row Background (Zebra)
                if (index % 2 === 0) {
                    doc.rect(40, doc.y, 515, doc.heightOfString(log.details, { width: 350 }) + 20).fillColor(colors.lightGray).fill();
                }

                const startY = doc.y + 5;

                // Timestamp
                doc.fontSize(8).font('Helvetica').fillColor(colors.gray).text(new Date(log.createdAt).toLocaleString(), 50, startY);

                // Author
                doc.fontSize(9).font('Helvetica-Bold').fillColor(colors.primary).text(log.actor?.name || 'System', 180, startY);
                doc.fontSize(7).font('Helvetica').fillColor(colors.gray).text(
                    `Ph: ${log.actor?.mobile || '-'} | ${log.actor?.email || '-'}`,
                    180, startY + 12, { width: 160 }
                );

                // Action Type Badge
                const isComment = log.action === 'COMMENT_ADDED';
                const actionColor = isComment ? colors.secondary : colors.gray;
                doc.fontSize(8).font('Helvetica-Bold').fillColor(actionColor).text(log.action.replace(/_/g, ' '), 350, startY);

                // Details
                doc.fontSize(9).font('Helvetica').fillColor(colors.text).text(log.details || '-', 50, startY + 25, { width: 490 });

                doc.moveDown(1);
            });
        } else {
            doc.text('No activity recorded.', 50, currentY);
        }

        // ================= SECTION: ATTACHMENTS =================
        if (ticket.attachments && ticket.attachments.length > 0) {
            doc.addPage();
            currentY = 40;
            currentY = drawSection('APPENDIX: EVIDENCE & ATTACHMENTS', currentY);

            for (const att of ticket.attachments) {
                // Determine file path
                let imagePath = null;
                if (att.url && att.url.startsWith('/uploads/')) {
                    imagePath = path.join(__dirname, '..', att.url);
                } else if (att.url) {
                    imagePath = path.join(__dirname, '..', 'uploads', path.basename(att.url));
                }

                if (imagePath && fs.existsSync(imagePath)) {
                    const ext = path.extname(imagePath).toLowerCase();
                    if (['.jpg', '.jpeg', '.png'].includes(ext)) {

                        if (doc.y + 450 > 800) doc.addPage();

                        try {
                            doc.image(imagePath, 50, doc.y, { fit: [500, 400], align: 'center' });
                            // Manually advance cursor since doc.image doesn't
                            doc.y += 420;
                        } catch (e) {
                            doc.fillColor('red').text(`[Error loading image: ${e.message}]`);
                            doc.fillColor(colors.text);
                            doc.moveDown();
                        }
                    }
                }
            }
        }

        // ================= SECTION 5: VERIFICATION =================
        doc.addPage();
        doc.y = 100; // Center vertically somewhat

        doc.fontSize(16).font('Helvetica-Bold').text('DOCUMENT VERIFICATION', { align: 'center' });
        doc.moveDown();

        const verifyUrl = `${process.env.FRONTEND_URL || 'http://localhost:5173'}/verify/${verifyToken}`;
        const qrCodeData = await QRCode.toDataURL(verifyUrl);

        doc.image(qrCodeData, (doc.page.width - 200) / 2, doc.y, { fit: [200, 200] });
        doc.moveDown(12); // Move past image

        doc.fontSize(10).font('Helvetica').text('Scan this QR code to verify the authenticity of this report.', { align: 'center' });
        doc.font('Helvetica-Bold').text(`Verification Token: ${verifyToken}`, { align: 'center', color: colors.primary });

        // End PDF generation
        doc.end();

        // Async Background Logging (Fire & Forget to not block download)
        (async () => {
            try {
                // Record Export (Metadata only)
                await prisma.ticketExport.create({
                    data: {
                        ticketId,
                        verifyToken,
                        pdfUrl: 'STREAMED_DOWNLOAD', // Placeholder since we stream
                        snapshotJson: JSON.stringify(ticket)
                    }
                });

                await prisma.activityLog.create({
                    data: {
                        ticketId,
                        // Assumes req.user is set via auth middleware
                        actorId: req.user ? req.user.id : null,
                        action: 'PDF_EXPORTED',
                        details: `PDF Report exported by ${req.user ? req.user.name : 'System'}`
                    }
                });
            } catch (postError) {
                console.error("Error saving export record:", postError);
            }
        })();

    } catch (error) {
        console.error("PDF Gen Error:", error);
        if (!res.headersSent) {
            res.status(500).json({ message: error.message });
        }
    }
};

const xlsx = require('xlsx');

// @desc    Export tickets to Excel
// @route   GET /api/tickets/export-excel
// @access  Private (Admin/COC)
const exportExcel = async (req, res) => {
    try {
        const { startDate, endDate } = req.query;

        // 1. Validation & Filter
        const where = {};
        if (startDate && endDate) {
            where.createdAt = {
                gte: new Date(startDate),
                lte: new Date(endDate)
            };
        }

        // 2. Fetch Data
        const tickets = await prisma.ticket.findMany({
            where,
            include: {
                createdBy: true,
                medicalReport: true,
                pitGridReport: true
            },
            orderBy: { createdAt: 'desc' }
        });

        // 3. Transform Data for Excel
        const data = tickets.map(t => ({
            'Ticket No': t.ticketNo,
            'Event': t.eventName,
            'Open Date': new Date(t.createdAt).toLocaleDateString(),
            'Closed Date': t.closedAt ? new Date(t.closedAt).toLocaleDateString() : '-',
            'Type': t.type,
            'Status': t.status,
            'Priority': t.priority,
            'Reporter': t.createdBy?.name || 'Unknown',
            'Description': t.description,
            'Assigned To': t.assignedToId || 'Unassigned',

            // Medical Specifics (Flattened if present)
            'Patient Name': t.medicalReport ? `${t.medicalReport.patientGivenName} ${t.medicalReport.patientSurname}` : '',
            'Injury Type': t.medicalReport?.injuryType || '',
            'License Action': t.medicalReport?.licenseAction || '',

            // Pit Specifics
            'Car No': t.pitGridReport?.carNumber || t.medicalReport?.carNumber || '',
            'Pit Violation': t.pitGridReport ? [
                t.pitGridReport.drivingOnWhiteLine ? 'White Line' : '',
                t.pitGridReport.refueling ? 'Refueling' : '',
                t.pitGridReport.excessMechanics ? 'Excess Mechanics' : ''
            ].filter(Boolean).join(', ') : ''
        }));

        // 4. Create Workbook
        const wb = xlsx.utils.book_new();
        const ws = xlsx.utils.json_to_sheet(data);
        xlsx.utils.book_append_sheet(wb, ws, 'Tickets');

        // 5. Write File
        const fileName = `tickets_export_${Date.now()}.xlsx`;
        const uploadsDir = path.join(__dirname, '..', 'uploads');
        if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir);

        const filePath = path.join(uploadsDir, fileName);
        xlsx.writeFile(wb, filePath);

        // 6. Return URL
        const downloadUrl = `http://localhost:3000/uploads/${fileName}`;
        res.json({ downloadUrl, count: tickets.length });

    } catch (error) {
        console.error('Excel Export Error:', error);
        res.status(500).json({ message: 'Excel export failed' });
    }
};

// @desc    Verify a report via QR token
// @route   GET /api/verify/:token
// @access  Public
const verifyReport = async (req, res) => {
    const { token } = req.params;

    try {
        const exportRecord = await prisma.ticketExport.findUnique({
            where: { verifyToken: token },
            include: { ticket: { include: { createdBy: { select: { name: true } } } } }
        });

        if (!exportRecord) {
            return res.status(404).json({ valid: false, message: 'Invalid or expired report token' });
        }

        res.json({
            valid: true,
            ticketNo: exportRecord.ticket.ticketNo,
            type: exportRecord.ticket.type,
            status: exportRecord.ticket.status,
            createdAt: exportRecord.ticket.createdAt,
            reporter: exportRecord.ticket.createdBy.name
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

module.exports = { exportPdf, exportExcel, verifyReport };
